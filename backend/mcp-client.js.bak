import { spawn } from 'child_process';
import { createInterface } from 'readline';
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import * as mcpConfig from './mcp-config.js';

const connections = new Map();
let _requestId = 0;

/**
 * Подключается к MCP серверу по HTTP (SSE)
 */
export async function connect(serverId, url) {
  try {
    // Если уже подключен, возвращаем существующее подключение
    if (connections.has(serverId)) {
      const existing = connections.get(serverId);
      if (existing.status === 'connected') {
        return { success: true, message: 'Already connected', client: existing.client };
      }
    }

    // Создаем новый клиент
    const client = new Client(
      {
        name: 'mcp-client',
        version: '1.0.0',
      },
      {
        capabilities: {},
      }
    );

    // Подключаемся через HTTP
    // Для HTTP транспорта используем fetch для отправки запросов
    const transport = {
      url: url,
      send: async (request) => {
        try {
          const response = await fetch(`${url}/mcp`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              method: request.method,
              params: request.params,
            }),
          });

          if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
          }

          return await response.json();
        } catch (error) {
          throw new Error(`Failed to send request: ${error.message}`);
        }
      },
    };

    // Сохраняем информацию о подключении
    connections.set(serverId, {
      client,
      transport,
      url,
      status: 'connected',
      connectedAt: new Date(),
    });

    // Тестируем подключение
    try {
      await listTools(serverId);
    } catch (error) {
      connections.set(serverId, {
        ...connections.get(serverId),
        status: 'error',
        error: error.message,
      });
      throw error;
    }

    return { success: true, client };
  } catch (error) {
    connections.set(serverId, {
      status: 'error',
      error: error.message,
      connectedAt: new Date(),
    });
    return { success: false, error: error.message };
  }
}

/**
 * Подключается к MCP серверу по stdio (command + args)
 */
export async function connectStdio(serverId, { command, args = [], env = {} }) {
  try {
    if (connections.has(serverId)) {
      const existing = connections.get(serverId);
      if (existing.status === 'connected') {
        return { success: true, message: 'Already connected' };
      }
      await disconnect(serverId);
    }

    const child = spawn(command, Array.isArray(args) ? args : [], {
      env: { ...process.env, ...env },
      stdio: ['pipe', 'pipe', 'pipe'],
    });

    const pending = new Map();
    const rl = createInterface({ input: child.stdout, terminal: false });

    rl.on('line', (line) => {
      if (!line.trim()) return;
      let msg;
      try {
        msg = JSON.parse(line);
      } catch {
        return;
      }
      const id = msg.id;
      if (id !== undefined && pending.has(id)) {
        const { resolve, reject } = pending.get(id);
        pending.delete(id);
        if (msg.error) {
          reject(new Error(msg.error.message || JSON.stringify(msg.error)));
        } else {
          resolve(msg.result);
        }
      }
    });

    child.stderr?.on('data', (chunk) => {
      const line = chunk.toString().trim();
      if (!line) return;
      const lower = line.toLowerCase();
      if (lower.includes('error') || lower.includes('exception') || lower.includes('failed') || lower.includes('warning')) {
        console.warn(`[MCP stdio ${serverId}] stderr:`, line);
      }
    });
    child.on('error', (err) => {
      console.error(`[MCP stdio ${serverId}] process error:`, err.message);
    });
    child.on('exit', (code, signal) => {
      if (connections.get(serverId)?.process === child) {
        connections.set(serverId, {
          ...connections.get(serverId),
          status: 'error',
          error: code != null ? `Process exited ${code}` : `Signal ${signal}`,
        });
      }
      for (const [, { reject }] of pending) {
        reject(new Error('Process exited'));
      }
      pending.clear();
    });

    const send = (request) => {
      return new Promise((resolve, reject) => {
        const id = ++_requestId;
        pending.set(id, { resolve, reject });
        const msg = { jsonrpc: '2.0', id, method: request.method, params: request.params || {} };
        child.stdin.write(JSON.stringify(msg) + '\n', (err) => {
          if (err) {
            pending.delete(id);
            reject(err);
          }
        });
      });
    };

    await send({ method: 'initialize', params: { protocolVersion: '2024-11-05', capabilities: {}, clientInfo: { name: 'mcp-client', version: '1.0.0' } } });
    child.stdin.write(JSON.stringify({ jsonrpc: '2.0', method: 'notifications/initialized' }) + '\n');

    const transport = { send };
    connections.set(serverId, {
      client: null,
      transport,
      url: `stdio:${command}`,
      status: 'connected',
      connectedAt: new Date(),
      process: child,
    });

    await listTools(serverId);
    return { success: true };
  } catch (error) {
    if (connections.has(serverId)) {
      const conn = connections.get(serverId);
      if (conn.process) conn.process.kill();
      connections.delete(serverId);
    }
    return { success: false, error: error.message };
  }
}

/**
 * Отключается от MCP сервера
 */
export async function disconnect(serverId) {
  if (connections.has(serverId)) {
    const conn = connections.get(serverId);
    if (conn.process) {
      conn.process.kill();
    }
    connections.delete(serverId);
    return { success: true };
  }
  return { success: false, error: 'Server not connected' };
}

/**
 * Получает список инструментов с сервера
 */
export async function listTools(serverId) {
  const connection = connections.get(serverId);
  if (!connection || connection.status !== 'connected') {
    throw new Error(`Server ${serverId} is not connected`);
  }

  try {
    const response = await connection.transport.send({
      method: 'tools/list',
      params: {},
    });

    return {
      success: true,
      tools: response.tools || [],
    };
  } catch (error) {
    throw new Error(`Failed to list tools: ${error.message}`);
  }
}

/**
 * Получает список инструментов со всех подключенных серверов
 */
export async function listAllTools() {
  const allTools = [];
  
  for (const [serverId, connection] of connections.entries()) {
    if (connection.status === 'connected') {
      try {
        const result = await listTools(serverId);
        const server = mcpConfig.getServer(serverId);
        
        result.tools.forEach(tool => {
          allTools.push({
            ...tool,
            serverId,
            serverName: server?.name || serverId,
          });
        });
      } catch (error) {
        console.error(`Error listing tools from ${serverId}:`, error);
      }
    }
  }
  
  return {
    success: true,
    tools: allTools,
  };
}

/**
 * Вызывает инструмент на сервере
 */
export async function callTool(serverId, toolName, args = {}) {
  const connection = connections.get(serverId);
  if (!connection || connection.status !== 'connected') {
    throw new Error(`Server ${serverId} is not connected`);
  }

  try {
    const response = await connection.transport.send({
      method: 'tools/call',
      params: {
        name: toolName,
        arguments: args,
      },
    });

    return {
      success: true,
      result: response,
    };
  } catch (error) {
    throw new Error(`Failed to call tool: ${error.message}`);
  }
}

/**
 * Получает статус подключения к серверу
 */
export function getServerStatus(serverId) {
  const connection = connections.get(serverId);
  if (!connection) {
    return { status: 'disconnected' };
  }

  return {
    status: connection.status,
    url: connection.url,
    connectedAt: connection.connectedAt,
    error: connection.error,
  };
}

/**
 * Получает статус всех подключений
 */
export function getAllServersStatus() {
  const statuses = {};
  
  for (const [serverId, connection] of connections.entries()) {
    statuses[serverId] = {
      status: connection.status,
      url: connection.url,
      connectedAt: connection.connectedAt,
      error: connection.error,
    };
  }
  
  return statuses;
}

/**
 * Инициализирует подключения к включенным серверам из конфигурации (url и stdio)
 */
export async function initializeConnections() {
  const enabledServers = mcpConfig.getEnabledServers();
  const results = [];

  for (const server of enabledServers) {
    try {
      let result;
      if (server.url) {
        result = await connect(server.id, server.url);
      } else if (server.command) {
        result = await connectStdio(server.id, {
          command: server.command,
          args: server.args || [],
          env: server.env || {},
        });
      } else {
        result = { success: false, error: 'Нет url или command' };
      }
      results.push({
        serverId: server.id,
        serverName: server.name,
        ...result,
      });
    } catch (error) {
      results.push({
        serverId: server.id,
        serverName: server.name,
        success: false,
        error: error.message,
      });
    }
  }

  return results;
}

/**
 * Тестирует подключение к серверу без сохранения
 */
export async function testConnection(url) {
  try {
    // Создаем временное подключение
    const testClient = {
      url: url,
      send: async (request) => {
        const response = await fetch(`${url}/mcp`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            method: request.method,
            params: request.params,
          }),
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        return await response.json();
      },
    };

    // Пробуем получить список инструментов
    const response = await testClient.send({
      method: 'tools/list',
      params: {},
    });

    return {
      success: true,
      toolsCount: response.tools?.length || 0,
    };
  } catch (error) {
    return {
      success: false,
      error: error.message,
    };
  }
}
